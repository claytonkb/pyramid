Backtracking and Constraint-solving Notes
=========================================

--> Back-trackable bstruct
    Save stack-trace while recursing
    For example, while recursing through a hash-table, store the pointers that
        have been traversed, in stack form. Push/pop manually during C recursion.
    This pays off when we get to enums, where we can specify an enum in a
        statement and then "iterate" across the elements of the enum each time
        we backtrack. The enum itself must be constant, but the backtracking
        can be nested simply by creating a new "frame" around the enum for
        each nested instance of an alternation.
    Think about back-trackable lists, arrays, etc.

* Branches, predicates, recursive LUTs, and branch-functions

    A LUT is an enumerated table:

        [map in0 out0
             in1 out1
             in2 out2
             ... ]

    A LUT can return another LUT; thus, all LUTs are recursive. A recursive
    LUT is called a LUT-function.

        (a b c) my_lut lut_fn
            ===
        c b a my_lut lut_eval lut_eval lut_eval

    A predicate is a test whose result is either true or false.

    A branch is a lookup that utilizes any of a set (ordered or not) of 
    predicates to select from a set of LUTs, functions or values.

    [branch
        ( predicate0 leaf0 )
        ( predicate1 leaf1 )
        ... ]

    A branch can be evaluated with respect to a value to select one of its
        leaves (it is a predicate-based LUT).

        value [branch ...] branch_eval --> leaf

    The result of a branch can be another branch; thus, branches are recursive. 
    A recursive branch table is called a branch-function.

        (a b c) my_branch branch_fn
            ===
        c b a my_branch branch_eval branch_eval branch_eval

    Branches that return LUTs; LUTs that return branches

* Non-branching code (aka "rod")

    Non-branching code needs to be able to be "run in reverse". There are two
    ways this can be done. First, the programmer may code up an inverse rod
    and provide this. When the rod is backtracked, the inverse function is
    executed by the interpreter to undo the forward-function. The other way
    is to allow the interpreter to manually accumulate an inverse-function as
    the rod is executed.

    We define an rstack entry to accumulate the inverse function. For example:

        3 7 +   --> 10 (rstack):{7 -}

        (| 3 7 +)
        (3 | 7 +)
        (3 7 | +)
        (10 |)

            +-----------+
            |  (+)-->   |
       3----|           |----10    NB: Order always matters because f^-1(x) is order-sensitive!
            |           |
       7----|           |---- 7
            |   <--(-)  |
            +-----------+

    Rods are used to prepare intermediate values for use in LUT- and branch-
    functions.

* Backtrackable functions

    Benefit: Easy, clear specification

* Constrainable functions

    Benefit: Find solutions automatically, instead of hand-solving

* Backtrackable-and-constrainable functions

    Benefits: Easy, clear specification
              Find solutions automatically, instead of hand-solving

