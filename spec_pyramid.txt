Pyramid Specification
=====================

Pyramid is the sub-virtual machine layer on which the Babel language is built.
Because modern CPUs are vector-oriented and because memory and temporal
locality have a large impact on performance, it is necessary for the Babel
interpreter to have a layer dedicated to gear-matching between idealized, list-
based structures describing the Babel Virtual Machine and the compact vector-
based structures in system memory.

Representations
---------------

* bstruct (machine representation)

    A Babel-struct (henceforth bstruct) is a non-dense data structure consisting
    of raw value-arrays (val), pointer-arrays (ptr) or tagged-pointers (tptr). A
    machine word (mword) is a data-value of machine width (e.g. 32-bit or 64-bit).
    HASH_SIZE is in units of mword-width (i.e. a 128-bit hash on a 32-bit machine
    has HASH_SIZE=4)

    bstruct : val | ptr | tptr
        val : mword | mword val
        ptr : bstruct | bstruct ptr 
       tptr : tag bstruct 
        tag : mword {HASH_SIZE}

    Implementation details of the underlying format are not specified.

* bstruct (canonical representation)

    A bstruct in machine-representation is machine-dependent - a 32-bit
    interpreter cannot read a 64-bit bstruct. For this reason and for
    abstraction, we specify a canonical representation for a bstruct.

    A canonical bstruct is a binary string (sequence).

            bstruct : header fields
             header : hash_width hash_fn_sig
                bit : [01]
              value : bit {width}
          bit_field : 1 {x} 0 (bit {2^x})->width value
         bit_fields : bit_field | bit_field bit_fields
          ptr_width : bit_field
         hash_width : bit_field
        hash_fn_sig : bit_field
             fields : field | field fields
              field : val | ptr | tptr
                val : 01 bit_field
                ptr : 11 bit_fields
               tptr : 00 bit {hash_width} ptr

    bit_field defines a prefix-free code for value. width is a parameter whose 
    value is 2^x, where,

        x = argmin(x) (2^x > value)

    A relative ptr in canonical encoding is significantly different than in the 
    machine-encoding. Instead of encoding an "offset" into the flattened bstruct, 
    it encodes a numerical index n which selects the nth *field* encoded in the 
    bstruct. Because every field is prefix-free, this index is always unambiguous.
    n is 0-indexed. The canonical ordering is defined to be depth-first traversal, 
    from 0 to i, where i is the number of fields in a ptr-array. If a bstruct
    is prefixed with another bstruct, its encoding must change. However, if
    it is postfixed with another bstruct, its encoding will remain the same, 
    except for the field pointing to the postfix.

* Converting between representations

    canonical(mr,bs) - converts bstruct bs from machine representation mr to 
    canonical representation

    hypostatic(bs,mr) - converts canonical bstruct bs to machine representation, mr

Axioms and Definitions
----------------------

    - canonical equivalence

        canonical(x,mr) = canonical(y,mr) <-> x === y

        mr is implied whenever the machine-representation is invariant 

    - value

        A value is an operand, combinator, or sequence of values

    - sequence (ordered set)

        (x y z) is defined to be the sequence consisting of values x, y and z

        ... x y z ... is a subsequence (ellipsis may be dropped)

    - combinator

        A combinator operates on an operand(s) to its left to produce a new
        operand which may be consumed by another combinator to its right.

        x y Z --> w

        Combinator Z operates on operands x y and to produce result w, which
        may be consumed by further combinators. This is called *application*.

        For the sake of formalizing the specification, we will write it in 
        functional form:

        apply(x, y, Z) = w

    - reduction

        A sequence of operands and combinators must have all the combinators
        applied, in order, until the sequence has been reduced. This repeated
        application is called *reduction*:

        x y Z a B --> c

        In this example, combinator Z consumes operands x and y to produce
        intermediate value w. Combinator B, in turn, consumes operands w and a
        to produce result c.

        A sequence of operands reduces to itself:

        x y z --> (x, y, z)

        In functional form:

        reduce(x, y, Z, a, B) = c

    - operands

        x = reduce(x) <-> x is an operand or sequence of operands

    - semantic meaning
        
        ( mu(x) = canonical(y) ) <--> ( reduce(x) = y )

        In other words, the semantic meaning of x is what x reduces to, irrespective 
        of the machine representation.

    - least canonical representation

        If x is not an operand,

            x =/= reduce(x)

        Thus,

            canonize(x) =/= canonize(reduce(x))

        However, 

            .- ( (reduce(x) = reduce(y)) --> x === y )

        ... since x and y may be different yet, when applied, have the same
        result.

        Since reduction is not onto, we define the least canonical representation 
        of x to be:

            lcr(x) = canonize(argmin(y)) reduce(y) = x

        It should be apparent that, if the logic described by our axioms is 
        Turing-complete, then lcr is uncomputable.







apply:<x,y> = (x:y). 

The result of apply:<x,y>, namely (x:y), is meaningless in FP systems on two 
levels. First, (x:y) is not itself an object; it illustrates another difference 
between FP and FFP systems: some FFP functions, like apply, map objects into 
expressions, not directly into objects as FP functions do. However, the meaning 
of apply:<x,y> is an object (see below). Second, (x:y) could not be even an 
intermediate result in an FP system; it is meaningless in FP systems since x 
is an object, not a function and FP systems do not associate functions with 
objects. 


[1] "Can Programming Be Liberated from the von Neumann Style? A Functional
Style and Its Algebra of Programs" - John Backus, Communications of the ACM 
Volume 21 Issue 8, Aug. 1978, Pages 613-641 

